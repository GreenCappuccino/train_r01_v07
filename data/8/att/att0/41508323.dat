.VERSION 1.0
.INCLUDE att/ccode.lex
.INCLUDE att/att0.doc
.INCLUDE att/data/att0/41508323.dat
.SEGMENT TEXT 16-31 ? "return NOTOK ;"
.SEGMENT TEXT 32-50 ? "return OK ; } int"
.SEGMENT TEXT 51-70 ? "return OK ; } int"
.SEGMENT TEXT 71-90 ? "nmwtend ( ) { ( void )"
.SEGMENT TEXT 113-132 ? "fclose ( fp ) ; if"
.SEGMENT TEXT 133-149 ? "fclose ( fp ) ; if"
.SEGMENT TEXT 150-168 ? "( link ( wrkfil ,"
.SEGMENT TEXT 206-224 ? "| unlink ( wrkfil )"
.SEGMENT TEXT 265-283 ? "= NOTOK ) return"
.SEGMENT TEXT 315-330 ? "OK ; } / * * /"
.SEGMENT TEXT 331-358 ? "OK ; } / * * /"
.SEGMENT TEXT 359-376 ? "static quefile"
.SEGMENT TEXT 377-392 ? "static quefile"
.SEGMENT TEXT 409-426 ? "char * que , * lnk ;"
.SEGMENT TEXT 427-445 ? "{ register char"
.SEGMENT TEXT 461-490 ? "* p , * q ; char buffer [ BUFSIZ ] ;"
.SEGMENT TEXT 576-595 ? "= getpid ( ) ; template.stamp.id"
.SEGMENT TEXT 596-618 ? "= getpid ( ) ; template.stamp.id"
.SEGMENT TEXT 619-642 ? "= files + ; if ( files"
.SEGMENT TEXT 643-667 ? "= files + ; if ( files"
.SEGMENT TEXT 684-696 ? "> = 256 ) { files"
.SEGMENT TEXT 697-711 ? "= 0 ; sleep ( 1 ) ;"
.SEGMENT TEXT 712-728 ? "= 0 ; sleep ( 1 ) ;"
.SEGMENT TEXT 729-736 ? "} ( void ) time"
.SEGMENT TEXT 766-795 ? "( & template.stamp.clock ) ;"
.SEGMENT TEXT 803-809 ? "p = buffer ; for"
.SEGMENT TEXT 889-916 ? "q + ) { * p + = hex [ ( *"
.SEGMENT TEXT 917-939 ? "> 4 ) & 0 xf ] ; * p +"
.SEGMENT TEXT 940-959 ? "> 4 ) & 0 xf ] ; * p +"
.SEGMENT TEXT 960-981 ? "= hex [ ( * q ) & 0 xf ] ;"
.SEGMENT TEXT 1004-1026 ? "} * p = NULL ; ( void )"
.SEGMENT TEXT 1027-1047 ? "} * p = NULL ; ( void )"
.SEGMENT TEXT 1061-1082 ? "\" % s / % s \" , Mailqdir ,"
.SEGMENT TEXT 1140-1157 ? "sprintf ( lnk ,"
.SEGMENT TEXT 1183-1212 ? "\" % s / % s \" , TMailqdir ,"
.SEGMENT TEXT 1254-1262 ? "* / static char"
.SEGMENT TEXT 1263-1276 ? "* / static char"
.SEGMENT TEXT 1277-1293 ? "* cdate ( clock )"
.SEGMENT TEXT 1294-1311 ? "* cdate ( clock )"
.SEGMENT TEXT 1316-1319 ? "register long"
.SEGMENT TEXT 1320-1334 ? "* clock ; { char"
.SEGMENT TEXT 1354-1366 ? "* cp ; cp = ctime"
.SEGMENT TEXT 1367-1379 ? "* cp ; cp = ctime"
.SEGMENT TEXT 1380-1395 ? "( clock ) ; cp [ 1 ]"
.SEGMENT TEXT 1413-1426 ? "= cp [ 8 ] ; cp [ 2 ]"
.SEGMENT TEXT 1427-1440 ? "= cp [ 8 ] ; cp [ 2 ]"
.SEGMENT TEXT 1441-1457 ? "= cp [ 9 ] ; cp [ 3 ]"
.SEGMENT TEXT 1506-1526 ? "' ; cp [ 8 ] = cp [ 22 ] ;"
.SEGMENT TEXT 1527-1549 ? "' ; cp [ 8 ] = cp [ 22 ] ;"
.SEGMENT TEXT 1550-1565 ? "cp [ 9 ] = cp [ 23 ] ;"
.SEGMENT TEXT 1566-1582 ? "cp [ 9 ] = cp [ 23 ] ;"
.SEGMENT TEXT 1583-1597 ? "cp [ 10 ] = ' @ ' ;"
.SEGMENT TEXT 1642-1655 ? "return cp + 1 ;"
.SEGMENT TEXT 1680-1691 ? "} / * modified"
.SEGMENT TEXT 1692-1709 ? "version of fscanf"
.SEGMENT TEXT 1728-1734 ? "SKIPS OVER COMMENTS"
.SEGMENT TEXT 1735-1758 ? "SKIPS OVER COMMENTS"
.SEGMENT TEXT 1759-1774 ? "comments start"
.SEGMENT TEXT 1775-1790 ? "comments start"
.SEGMENT TEXT 1791-1800 ? "with a hash ( # )"
.SEGMENT TEXT 1834-1839 ? "end of the line"
.SEGMENT TEXT 1840-1845 ? "end of the line"
.SEGMENT TEXT 1846-1861 ? "Restrictions :"
.SEGMENT TEXT 1885-1890 ? "Only eats comments"
.SEGMENT TEXT 1891-1905 ? "once. Therefore"
.SEGMENT TEXT 1906-1920 ? "once. Therefore"
.SEGMENT TEXT 1976-1991 ? "% d \" , & a , & b ) ;"
.SEGMENT TEXT 2052-2057 ? "the two numbers."
.SEGMENT TEXT 2058-2064 ? "the two numbers."
.SEGMENT TEXT 2065-2079 ? "The preferred"
.SEGMENT TEXT 2080-2093 ? "The preferred"
.SEGMENT TEXT 2094-2101 ? "technique is to"
.SEGMENT TEXT 2121-2131 ? "read one at a"
.SEGMENT TEXT 2170-2191 ? "\" , & a ) ; f 1scanf ( fp ,"
.SEGMENT TEXT 2215-2231 ? "\" % d \" , & b ) ; Also ,"
.SEGMENT TEXT 2232-2248 ? "\" % d \" , & b ) ; Also ,"
.SEGMENT TEXT 2249-2267 ? "if you are reading"
.SEGMENT TEXT 2268-2286 ? "if you are reading"
.SEGMENT TEXT 2287-2300 ? "strings with \" % s \""
.SEGMENT TEXT 2315-2332 ? "format , you must"
.SEGMENT TEXT 2333-2350 ? "format , you must"
.SEGMENT TEXT 2351-2358 ? "not run the string"
.SEGMENT TEXT 2359-2366 ? "not run the string"
.SEGMENT TEXT 2383-2396 ? "up against the"
.SEGMENT TEXT 2397-2403 ? "hash. Terminate"
.SEGMENT TEXT 2413-2430 ? "your string with"
.SEGMENT TEXT 2506-2516 ? "/ * Usage example :"
.SEGMENT TEXT 2542-2566 ? "* # include < stdio.h >"
.SEGMENT TEXT 2613-2627 ? "main ( int argc ,"
.SEGMENT TEXT 2628-2635 ? "char * argv ) {"
.SEGMENT TEXT 2646-2665 ? "if ( argc ) if ( argv )"
.SEGMENT TEXT 2666-2685 ? "if ( argc ) if ( argv )"
.SEGMENT TEXT 2725-2741 ? "str [ 100 ] ; int"
.SEGMENT TEXT 2752-2761 ? "num ; for ( ; ) {"
.SEGMENT TEXT 2762-2787 ? "krud = f 1scanf ( stdin ,"
.SEGMENT TEXT 2889-2902 ? "break ; printf ( \" % d"
.SEGMENT TEXT 2963-2977 ? "krud = f 1scanf ( stdin ,"
.SEGMENT TEXT 2978-2997 ? "\" % d \" , & num ) ; if"
.SEGMENT TEXT 3028-3040 ? "( krud < 0 ) break ;"
.SEGMENT TEXT 3061-3085 ? "printf ( \" % d % d \\ n \" ,"
.SEGMENT TEXT 3086-3093 ? "krud , num ) ; }"
.SEGMENT TEXT 3094-3104 ? "krud , num ) ; }"
.SEGMENT TEXT 3105-3119 ? "} . # this is"
.SEGMENT TEXT 3120-3134 ? "} . # this is"
.SEGMENT TEXT 3135-3140 ? "an example data"
.SEGMENT TEXT 3141-3146 ? "an example data"
.SEGMENT TEXT 3147-3160 ? "file abcd 1234"
.SEGMENT TEXT 3161-3174 ? "file abcd 1234"
.SEGMENT TEXT 3175-3186 ? "# comment # comment"
.SEGMENT TEXT 3214-3228 ? "all by itself"
.SEGMENT TEXT 3229-3240 ? "xyz # comment"
.SEGMENT TEXT 3282-3300 ? "# blank lines"
.SEGMENT TEXT 3346-3357 ? "999999 # end of"
.SEGMENT TEXT 3358-3374 ? "example file *"
.SEGMENT TEXT 3375-3391 ? "example file *"
.SEGMENT TEXT 3461-3472 ? "= ' ' ; static"
.SEGMENT TEXT 3473-3482 ? "= ' ' ; static"
.SEGMENT TEXT 3483-3496 ? "char tab = ' ' ;"
.SEGMENT TEXT 3518-3522 ? "static char nl"
.SEGMENT TEXT 3542-3561 ? "= 10 ; static char"
.SEGMENT TEXT 3562-3576 ? "hash = ' # ' ; int"
.SEGMENT TEXT 3613-3634 ? "f 1scanf ( fp , control"
.SEGMENT TEXT 3635-3643 ? "char * control ;"
.SEGMENT TEXT 3686-3699 ? "char ch ; for ( ; ) {"
.SEGMENT TEXT 3700-3710 ? "char ch ; for ( ; ) {"
.SEGMENT TEXT 3772-3787 ? "break ; if ( ch"
.SEGMENT TEXT 3788-3802 ? "break ; if ( ch"
.SEGMENT TEXT 3803-3811 ? "= sp ) continue ;"
.SEGMENT TEXT 3812-3820 ? "= sp ) continue ;"
.SEGMENT TEXT 3848-3857 ? "continue ; if ( ch"
.SEGMENT TEXT 3866-3885 ? "= nl ) continue ;"
.SEGMENT TEXT 3906-3913 ? "if ( ch = hash )"
.SEGMENT TEXT 3934-3945 ? "{ for ( ; ) { ch"
.SEGMENT TEXT 3973-3983 ? "( ch = EOF ) goto"
.SEGMENT TEXT 3984-4001 ? "( ch = EOF ) goto"
.SEGMENT TEXT 4002-4016 ? "done ; if ( ch ="
.SEGMENT TEXT 4017-4029 ? "done ; if ( ch ="
.SEGMENT TEXT 4030-4055 ? "nl ) break ; } continue ;"
.SEGMENT TEXT 4056-4078 ? "nl ) break ; } continue ;"
.SEGMENT TEXT 4079-4090 ? "} / * here if it"
.SEGMENT TEXT 4091-4100 ? "} / * here if it"
.SEGMENT TEXT 4101-4113 ? "was a readable"
.SEGMENT TEXT 4114-4127 ? "was a readable"
.SEGMENT TEXT 4128-4140 ? "character * / ungetc ( ch ,"
.SEGMENT TEXT 4153-4167 ? "fp ) ; break ; }"
.SEGMENT TEXT 4195-4201 ? "done : return ("
.SEGMENT TEXT 4230-4235 ? "/ / standalone"
.SEGMENT TEXT 4236-4239 ? "/ / standalone"
.SEGMENT TEXT 4257-4274 ? "program that can"
.SEGMENT TEXT 4275-4279 ? "read a network"
.SEGMENT TEXT 4285-4301 ? "description from"
.SEGMENT TEXT 4302-4319 ? "description from"
.SEGMENT TEXT 4339-4356 ? "then reads inputs"
.SEGMENT TEXT 4357-4375 ? "then reads inputs"
.SEGMENT TEXT 4425-4435 ? "to stdout. / typical"
.SEGMENT TEXT 4462-4477 ? "usage : < input"
.SEGMENT TEXT 4478-4483 ? "fprop mynet.fp"
.SEGMENT TEXT 4484-4494 ? "fprop mynet.fp"
.SEGMENT TEXT 4524-4530 ? "no . fp filename"
.SEGMENT TEXT 4593-4600 ? "line , the default"
.SEGMENT TEXT 4624-4648 ? "is test1. fp # include"
.SEGMENT TEXT 4681-4707 ? "< libc.h > # include"
.SEGMENT TEXT 4746-4760 ? "\" fprop.h \" # include"
.SEGMENT TEXT 4805-4818 ? "\" readnet.h \" # include"
.SEGMENT TEXT 4859-4889 ? "\" f 1scanf.h \" # include"
.SEGMENT TEXT 4890-4911 ? "\" iodef.h \" / ISA :"
.SEGMENT TEXT 4930-4945 ? "important for"
.SEGMENT TEXT 4946-4962 ? "important for"
.SEGMENT TEXT 4967-4975 ? "I / O definition"
.SEGMENT TEXT 4976-4998 ? "extern FILE * in"
.SEGMENT TEXT 5032-5042 ? "= stdin ; extern"
.SEGMENT TEXT 5043-5072 ? "FILE * out = stdout ;"
.SEGMENT TEXT 5103-5116 ? "static NetArea"
.SEGMENT TEXT 5117-5125 ? "static NetArea"
.SEGMENT TEXT 5152-5161 ? "0, 0 , 0 , 0 , 0 ,"
.SEGMENT TEXT 5206-5218 ? "int main ( int argc ,"
.SEGMENT TEXT 5219-5233 ? "char * argv ) { /"
.SEGMENT TEXT 5265-5283 ? "from command line ,"
.SEGMENT TEXT 5301-5306 ? "or use default :"
.SEGMENT TEXT 5307-5312 ? "or use default :"
.SEGMENT TEXT 5313-5333 ? "char * name = argc > 1"
.SEGMENT TEXT 5334-5356 ? "char * name = argc > 1"
.SEGMENT TEXT 5357-5378 ? "? argv [ 1 ] : \" test1. fp \" ;"
.SEGMENT TEXT 5379-5400 ? "? argv [ 1 ] : \" test1. fp \" ;"
.SEGMENT TEXT 5401-5432 ? "FILE * fp = fopen ( name ,"
.SEGMENT TEXT 5433-5465 ? "FILE * fp = fopen ( name ,"
.SEGMENT TEXT 5466-5493 ? "\" r \" ) ; char bufin [ BUFSIZE ] ;"
.SEGMENT TEXT 5550-5572 ? "setbuf ( in , bufin ) ;"
.SEGMENT TEXT 5595-5615 ? "char bufout [ BUFSIZE ] ;"
.SEGMENT TEXT 5686-5704 ? "if ( ! fp ) { fprintf ( stderr ,"
.SEGMENT TEXT 5705-5719 ? "\" ? Cannot open"
.SEGMENT TEXT 5720-5734 ? "\" ? Cannot open"
.SEGMENT TEXT 5767-5785 ? "name ) ; exit ( 2 ) ;"
.SEGMENT TEXT 5804-5809 ? "} / see if we"
.SEGMENT TEXT 5834-5852 ? "are taking input"
.SEGMENT TEXT 5853-5860 ? "from an interactive"
.SEGMENT TEXT 5869-5887 ? "tty : const int"
.SEGMENT TEXT 5988-6003 ? "if ( ! fp ) exit ( 1 ) ;"
.SEGMENT TEXT 6004-6017 ? "/ allocate the"
.SEGMENT TEXT 6018-6031 ? "/ allocate the"
.SEGMENT TEXT 6032-6040 ? "network descriptor :"
.SEGMENT TEXT 6041-6049 ? "network descriptor :"
.SEGMENT TEXT 6050-6061 ? "Net mynet ; / read"
.SEGMENT TEXT 6062-6079 ? "Net mynet ; / read"
.SEGMENT TEXT 6080-6088 ? "in the weights ,"
