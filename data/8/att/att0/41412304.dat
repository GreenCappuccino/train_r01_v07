.VERSION 1.0
.INCLUDE att/ccode.lex
.INCLUDE att/att0.doc
.INCLUDE att/data/att0/41412304.dat
.SEGMENT TEXT 0-16 ? "= NOTOK ) return"
.SEGMENT TEXT 17-32 ? "= NOTOK ) return"
.SEGMENT TEXT 33-48 ? "NOTOK ; return"
.SEGMENT TEXT 65-78 ? "OK ; } / * * /"
.SEGMENT TEXT 96-113 ? "static quefile"
.SEGMENT TEXT 114-135 ? "static quefile"
.SEGMENT TEXT 136-155 ? "( que , lnk ) register"
.SEGMENT TEXT 156-177 ? "( que , lnk ) register"
.SEGMENT TEXT 178-200 ? "char * que , * lnk ;"
.SEGMENT TEXT 223-236 ? "{ register char"
.SEGMENT TEXT 352-391 ? "= getpid ( ) ; template.stamp.id"
.SEGMENT TEXT 392-415 ? "= files + ; if ( files"
.SEGMENT TEXT 416-439 ? "= files + ; if ( files"
.SEGMENT TEXT 456-472 ? "> = 256 ) { files"
.SEGMENT TEXT 489-504 ? "= 0 ; sleep ( 1 ) ;"
.SEGMENT TEXT 532-544 ? "( & template.stamp.clock ) ;"
.SEGMENT TEXT 545-557 ? "( & template.stamp.clock ) ;"
.SEGMENT TEXT 576-593 ? "p = buffer ; for"
.SEGMENT TEXT 594-605 ? "( q = template.nbytes ;"
.SEGMENT TEXT 618-641 ? "q + ) { * p + = hex [ ( *"
.SEGMENT TEXT 642-664 ? "q + ) { * p + = hex [ ( *"
.SEGMENT TEXT 665-684 ? "> 4 ) & 0 xf ] ; * p +"
.SEGMENT TEXT 703-724 ? "= hex [ ( * q ) & 0 xf ] ;"
.SEGMENT TEXT 725-746 ? "= hex [ ( * q ) & 0 xf ] ;"
.SEGMENT TEXT 747-766 ? "} * p = NULL ; ( void )"
.SEGMENT TEXT 767-787 ? "} * p = NULL ; ( void )"
.SEGMENT TEXT 805-820 ? "sprintf ( que ,"
.SEGMENT TEXT 821-839 ? "\" % s / % s \" , Mailqdir ,"
.SEGMENT TEXT 860-877 ? "buffer ) ; ( void )"
.SEGMENT TEXT 953-964 ? "* / static char"
.SEGMENT TEXT 965-981 ? "* cdate ( clock )"
.SEGMENT TEXT 1024-1038 ? "* clock ; { char"
.SEGMENT TEXT 1052-1063 ? "* cp ; cp = ctime"
.SEGMENT TEXT 1064-1078 ? "( clock ) ; cp [ 1 ]"
.SEGMENT TEXT 1079-1093 ? "( clock ) ; cp [ 1 ]"
.SEGMENT TEXT 1094-1105 ? "= cp [ 8 ] ; cp [ 2 ]"
.SEGMENT TEXT 1106-1117 ? "= cp [ 8 ] ; cp [ 2 ]"
.SEGMENT TEXT 1134-1149 ? "= cp [ 9 ] ; cp [ 3 ]"
.SEGMENT TEXT 1150-1162 ? "= ' - ' ; cp [ 7 ] ="
.SEGMENT TEXT 1163-1175 ? "= ' - ' ; cp [ 7 ] ="
.SEGMENT TEXT 1242-1255 ? "cp [ 10 ] = ' @ ' ;"
.SEGMENT TEXT 1256-1269 ? "cp [ 10 ] = ' @ ' ;"
.SEGMENT TEXT 1281-1290 ? "cp [ 19 ] = NULL ;"
.SEGMENT TEXT 1291-1306 ? "return cp + 1 ;"
.SEGMENT TEXT 1307-1321 ? "return cp + 1 ;"
.SEGMENT TEXT 1322-1329 ? "} / * modified"
.SEGMENT TEXT 1330-1337 ? "} / * modified"
.SEGMENT TEXT 1338-1356 ? "version of fscanf"
.SEGMENT TEXT 1357-1376 ? "version of fscanf"
.SEGMENT TEXT 1377-1386 ? "SKIPS OVER COMMENTS"
.SEGMENT TEXT 1387-1391 ? "SKIPS OVER COMMENTS"
.SEGMENT TEXT 1392-1407 ? "comments start"
.SEGMENT TEXT 1447-1459 ? "and run to the"
.SEGMENT TEXT 1460-1474 ? "and run to the"
.SEGMENT TEXT 1475-1480 ? "end of the line"
.SEGMENT TEXT 1487-1506 ? "Restrictions :"
.SEGMENT TEXT 1527-1531 ? "Only eats comments"
.SEGMENT TEXT 1583-1594 ? "f 1scanf ( fp , \" % d"
.SEGMENT TEXT 1595-1609 ? "% d \" , & a , & b ) ;"
.SEGMENT TEXT 1610-1624 ? "% d \" , & a , & b ) ;"
.SEGMENT TEXT 1625-1631 ? "is a comment between"
.SEGMENT TEXT 1639-1653 ? "the two numbers."
.SEGMENT TEXT 1654-1668 ? "the two numbers."
.SEGMENT TEXT 1672-1673 ? "The preferred"
.SEGMENT TEXT 1691-1707 ? "technique is to"
.SEGMENT TEXT 1708-1712 ? "read one at a"
.SEGMENT TEXT 1744-1770 ? "time : f 1scanf ( fp ,"
.SEGMENT TEXT 1864-1869 ? "if you are reading"
.SEGMENT TEXT 1929-1936 ? "not run the string"
.SEGMENT TEXT 1937-1954 ? "up against the"
.SEGMENT TEXT 1955-1970 ? "up against the"
.SEGMENT TEXT 1971-1976 ? "hash. Terminate"
.SEGMENT TEXT 1977-1982 ? "hash. Terminate"
.SEGMENT TEXT 1983-2002 ? "your string with"
.SEGMENT TEXT 2024-2029 ? "a space , tab ,"
.SEGMENT TEXT 2030-2035 ? "a space , tab ,"
.SEGMENT TEXT 2052-2066 ? "or newline. * /"
.SEGMENT TEXT 2067-2075 ? "/ * Usage example :"
.SEGMENT TEXT 2076-2085 ? "/ * Usage example :"
.SEGMENT TEXT 2112-2138 ? "* # include < stdio.h >"
.SEGMENT TEXT 2139-2159 ? "# include \" f 1scanf.h \""
.SEGMENT TEXT 2160-2174 ? "# include \" f 1scanf.h \""
.SEGMENT TEXT 2193-2212 ? "main ( int argc ,"
.SEGMENT TEXT 2280-2288 ? "; int krud ; char"
.SEGMENT TEXT 2289-2305 ? "str [ 100 ] ; int"
.SEGMENT TEXT 2306-2322 ? "str [ 100 ] ; int"
.SEGMENT TEXT 2323-2331 ? "num ; for ( ; ) {"
.SEGMENT TEXT 2341-2366 ? "krud = f 1scanf ( stdin ,"
.SEGMENT TEXT 2367-2393 ? "krud = f 1scanf ( stdin ,"
.SEGMENT TEXT 2394-2409 ? "\" % 99 s \" , str ) ;"
.SEGMENT TEXT 2426-2437 ? "if ( krud < 0 )"
.SEGMENT TEXT 2499-2520 ? "% s \\ n \" , krud , str ) ;"
.SEGMENT TEXT 2569-2584 ? "( krud < 0 ) break ;"
.SEGMENT TEXT 2585-2603 ? "printf ( \" % d % d \\ n \" ,"
.SEGMENT TEXT 2604-2623 ? "printf ( \" % d % d \\ n \" ,"
.SEGMENT TEXT 2624-2635 ? "krud , num ) ; }"
.SEGMENT TEXT 2636-2647 ? "krud , num ) ; }"
.SEGMENT TEXT 2648-2658 ? "} . # this is"
.SEGMENT TEXT 2659-2669 ? "} . # this is"
.SEGMENT TEXT 2688-2705 ? "an example data"
.SEGMENT TEXT 2747-2773 ? "# comment # comment"
.SEGMENT TEXT 2774-2778 ? "all by itself"
.SEGMENT TEXT 2779-2783 ? "all by itself"
.SEGMENT TEXT 2801-2818 ? "xyz # comment"
.SEGMENT TEXT 2854-2871 ? "# blank lines"
.SEGMENT TEXT 2877-2883 ? "are ok : aaaaaaa"
.SEGMENT TEXT 2884-2901 ? "999999 # end of"
.SEGMENT TEXT 2925-2931 ? "example file *"
.SEGMENT TEXT 2932-2959 ? "* / # include < stdio.h >"
.SEGMENT TEXT 2960-2987 ? "* / # include < stdio.h >"
.SEGMENT TEXT 2988-2993 ? "static char sp"
.SEGMENT TEXT 3013-3027 ? "= ' ' ; static"
.SEGMENT TEXT 3062-3076 ? "static char nl"
.SEGMENT TEXT 3077-3087 ? "= 10 ; static char"
.SEGMENT TEXT 3088-3098 ? "= 10 ; static char"
.SEGMENT TEXT 3099-3118 ? "hash = ' # ' ; int"
.SEGMENT TEXT 3182-3209 ? ", pnum ) FILE * fp ;"
.SEGMENT TEXT 3243-3259 ? "void * pnum ; {"
.SEGMENT TEXT 3270-3279 ? "char ch ; for ( ; ) {"
.SEGMENT TEXT 3280-3296 ? "ch = getc ( fp ) ;"
.SEGMENT TEXT 3297-3313 ? "ch = getc ( fp ) ;"
.SEGMENT TEXT 3314-3327 ? "if ( ch = EOF )"
.SEGMENT TEXT 3356-3369 ? "break ; if ( ch"
.SEGMENT TEXT 3370-3378 ? "= sp ) continue ;"
.SEGMENT TEXT 3388-3401 ? "if ( ch = tab )"
.SEGMENT TEXT 3423-3431 ? "continue ; if ( ch"
.SEGMENT TEXT 3471-3478 ? "if ( ch = hash )"
.SEGMENT TEXT 3513-3523 ? "( ch = EOF ) goto"
.SEGMENT TEXT 3524-3537 ? "( ch = EOF ) goto"
.SEGMENT TEXT 3538-3553 ? "done ; if ( ch ="
.SEGMENT TEXT 3554-3569 ? "done ; if ( ch ="
.SEGMENT TEXT 3592-3608 ? "} / * here if it"
.SEGMENT TEXT 3626-3628 ? "was a readable"
.SEGMENT TEXT 3629-3631 ? "was a readable"
.SEGMENT TEXT 3632-3656 ? "character * / ungetc ( ch ,"
.SEGMENT TEXT 3657-3681 ? "character * / ungetc ( ch ,"
.SEGMENT TEXT 3682-3689 ? "fp ) ; break ; }"
.SEGMENT TEXT 3728-3733 ? "done : return ("
.SEGMENT TEXT 3753-3768 ? "/ / standalone"
.SEGMENT TEXT 3793-3807 ? "read a network"
.SEGMENT TEXT 3835-3851 ? "a . fp file / and"
.SEGMENT TEXT 3882-3899 ? "from stdin and"
.SEGMENT TEXT 3900-3906 ? "writes the results"
.SEGMENT TEXT 3907-3914 ? "writes the results"
.SEGMENT TEXT 3915-3937 ? "to stdout. / typical"
.SEGMENT TEXT 3961-3967 ? "usage : < input"
.SEGMENT TEXT 3968-3974 ? "usage : < input"
.SEGMENT TEXT 3975-3994 ? "fprop mynet.fp"
.SEGMENT TEXT 4015-4021 ? "> output / if"
.SEGMENT TEXT 4022-4028 ? "> output / if"
.SEGMENT TEXT 4029-4045 ? "no . fp filename"
.SEGMENT TEXT 4063-4069 ? "line , the default"
.SEGMENT TEXT 4104-4130 ? "is test1. fp # include"
.SEGMENT TEXT 4131-4147 ? "< stdio.h > # include"
.SEGMENT TEXT 4218-4230 ? "\" fprop.h \" # include"
.SEGMENT TEXT 4258-4282 ? "\" fpeng.h \" # include"
.SEGMENT TEXT 4297-4310 ? "\" readnet.h \" # include"
.SEGMENT TEXT 4411-4429 ? "important for"
.SEGMENT TEXT 4430-4446 ? "important for"
.SEGMENT TEXT 4457-4464 ? "I / O definition"
.SEGMENT TEXT 4465-4489 ? "extern FILE * in"
.SEGMENT TEXT 4490-4514 ? "extern FILE * in"
.SEGMENT TEXT 4525-4534 ? "= stdin ; extern"
.SEGMENT TEXT 4600-4606 ? "static NetArea"
.SEGMENT TEXT 4643-4653 ? "0, 0 , 0 , 0 , 0 ,"
.SEGMENT TEXT 4666-4679 ? "0, 0 , 0 , 0 , 0 } ;"
.SEGMENT TEXT 4716-4730 ? "char * argv ) { /"
.SEGMENT TEXT 4731-4735 ? "pick up filename"
.SEGMENT TEXT 4760-4778 ? "from command line ,"
.SEGMENT TEXT 4786-4791 ? "or use default :"
.SEGMENT TEXT 4812-4831 ? "char * name = argc > 1"
.SEGMENT TEXT 4832-4852 ? "? argv [ 1 ] : \" test1. fp \" ;"
.SEGMENT TEXT 4853-4872 ? "? argv [ 1 ] : \" test1. fp \" ;"
.SEGMENT TEXT 4906-4937 ? "FILE * fp = fopen ( name ,"
.SEGMENT TEXT 5015-5037 ? "setbuf ( in , bufin ) ;"
.SEGMENT TEXT 5038-5048 ? "setbuf ( out , bufout ) ;"
.SEGMENT TEXT 5095-5129 ? "if ( ! fp ) { fprintf ( stderr ,"
.SEGMENT TEXT 5130-5136 ? "\" ? Cannot open"
.SEGMENT TEXT 5144-5160 ? "file ' % s'\\ n \" ,"
.SEGMENT TEXT 5161-5177 ? "file ' % s'\\ n \" ,"
.SEGMENT TEXT 5204-5214 ? "} / see if we"
.SEGMENT TEXT 5233-5239 ? "are taking input"
.SEGMENT TEXT 5306-5323 ? "interactive ="
.SEGMENT TEXT 5342-5353 ? "isatty ( fileno ( in ) ;"
.SEGMENT TEXT 5366-5389 ? "if ( ! fp ) exit ( 1 ) ;"
.SEGMENT TEXT 5504-5521 ? "in the weights ,"
.SEGMENT TEXT 5529-5535 ? "structure , etc."
.SEGMENT TEXT 5553-5570 ? "from the file :"
.SEGMENT TEXT 5571-5577 ? "fprintf ( stderr ,"
.SEGMENT TEXT 5578-5584 ? "fprintf ( stderr ,"
.SEGMENT TEXT 5600-5614 ? "\" Loading net ,"
.SEGMENT TEXT 5615-5619 ? "please wait ."
.SEGMENT TEXT 5625-5645 ? "\\ n \" ) ; readnet ( fp ,"
.SEGMENT TEXT 5675-5681 ? "mynet , myna ) ;"
.SEGMENT TEXT 5682-5701 ? "if ( ! mynet.anl )"
.SEGMENT TEXT 5702-5720 ? "if ( ! mynet.anl )"
.SEGMENT TEXT 5721-5737 ? "exit ( 2 ) ; fprintf ( stderr ,"
.SEGMENT TEXT 5738-5753 ? "exit ( 2 ) ; fprintf ( stderr ,"
.SEGMENT TEXT 5754-5779 ? "\" Ready ! \\ n \" ) ; for ( ; ) {"
.SEGMENT TEXT 5780-5807 ? "\" Ready ! \\ n \" ) ; for ( ; ) {"
.SEGMENT TEXT 5822-5825 ? "/ loop over all"
.SEGMENT TEXT 5857-5865 ? "if ( interactive )"
.SEGMENT TEXT 5875-5894 ? "{ / print a prompt"
.SEGMENT TEXT 5915-5921 ? "fprintf ( stderr ,"
.SEGMENT TEXT 5945-5960 ? "\" - > \" ) ; / so user"
.SEGMENT TEXT 5961-5966 ? "will know we're"
.SEGMENT TEXT 5967-5972 ? "will know we're"
.SEGMENT TEXT 6002-6030 ? "waiting fflush ( stderr ) ;"
.SEGMENT TEXT 6035-6038 ? "} / loop over"
.SEGMENT TEXT 6039-6051 ? "all numbers in"
.SEGMENT TEXT 6065-6071 ? "this input record"
.SEGMENT TEXT 6111-6125 ? "0 ; ii < mynet.nin ;"
.SEGMENT TEXT 6140-6157 ? "ii + ) { / read them"
.SEGMENT TEXT 6158-6175 ? "ii + ) { / read them"
.SEGMENT TEXT 6176-6181 ? "directly into"
.SEGMENT TEXT 6182-6187 ? "directly into"
.SEGMENT TEXT 6206-6223 ? "the input unit"
.SEGMENT TEXT 6232-6239 ? "activation levels :"
.SEGMENT TEXT 6240-6266 ? "# ifdef ASCII int"
.SEGMENT TEXT 6304-6313 ? "krud = f 1scanf ( in ,"
.SEGMENT TEXT 6385-6401 ? "! = 1 ) { if ( krud"
.SEGMENT TEXT 6402-6417 ? "! = 1 ) { if ( krud"
.SEGMENT TEXT 6436-6453 ? "= EOF & ii = 0 )"
.SEGMENT TEXT 6488-6521 ? "exit ( 0 ) ; fprintf ( stderr ,"
.SEGMENT TEXT 6522-6538 ? "\" ? Bad input \\ n \" ) ;"
.SEGMENT TEXT 6578-6600 ? "exit ( 1 ) ; } # elif"
.SEGMENT TEXT 6611-6620 ? "krud = f 1scanf ( in ,"
.SEGMENT TEXT 6642-6662 ? "\" % f \" , mynet.in"
.SEGMENT TEXT 6663-6675 ? "+ ii ) ; if ( krud"
.SEGMENT TEXT 6676-6688 ? "+ ii ) ; if ( krud"
.SEGMENT TEXT 6756-6789 ? "exit ( 0 ) ; fprintf ( stderr ,"
.SEGMENT TEXT 6790-6822 ? "exit ( 0 ) ; fprintf ( stderr ,"
.SEGMENT TEXT 6878-6900 ? "exit ( 1 ) ; } # elif"
.SEGMENT TEXT 6915-6927 ? "+ ii , sizeof ( float ) ,"
.SEGMENT TEXT 6953-6977 ? "1, in ) ; if ( ferror ( in )"
.SEGMENT TEXT 7056-7071 ? "exit ( 1 ) ; } # endif"
.SEGMENT TEXT 7088-7099 ? "} / here with"
.SEGMENT TEXT 7100-7111 ? "} / here with"
.SEGMENT TEXT 7112-7118 ? "input set up /"
.SEGMENT TEXT 7119-7125 ? "input set up /"
.SEGMENT TEXT 7222-7225 ? "/ loop over all"
.SEGMENT TEXT 7242-7257 ? "numbers in this"
.SEGMENT TEXT 7258-7263 ? "output record :"
.SEGMENT TEXT 7311-7324 ? "0 ; oo < mynet.nout ;"
.SEGMENT TEXT 7396-7408 ? "fprintf ( out , \" % f"
.SEGMENT TEXT 7473-7492 ? "# else fwrite ( & mynet.out [ oo ] ,"
.SEGMENT TEXT 7511-7525 ? "sizeof ( float ) ,"
.SEGMENT TEXT 7526-7539 ? "1, out ) ; # endif"
.SEGMENT TEXT 7576-7598 ? "} # ifdef ASCII"
.SEGMENT TEXT 7599-7614 ? "fprintf ( out , \" \\ n \" ) ;"
.SEGMENT TEXT 7696-7706 ? "} } / * netmail.c"
.SEGMENT TEXT 7707-7721 ? "- queue mail for"
.SEGMENT TEXT 7822-7842 ? "* / # include \" . / h / strings.h \""
.SEGMENT TEXT 7866-7888 ? "# include < stdio.h >"
.SEGMENT TEXT 7889-7908 ? "# include \" . / zotnet / mts.h \""
.SEGMENT TEXT 7929-7950 ? "# define NOTOK"
.SEGMENT TEXT 7951-7970 ? "# define NOTOK"
.SEGMENT TEXT 7971-7983 ? "( - 1 ) # define OK"
.SEGMENT TEXT 7984-7994 ? "( - 1 ) # define OK"
.SEGMENT TEXT 8063-8080 ? "= 0 ; static char"
.SEGMENT TEXT 8081-8098 ? "= 0 ; static char"
.SEGMENT TEXT 8099-8134 ? "hex [ ] = \" 0123456789 ABCDEF \" ;"
.SEGMENT TEXT 8183-8202 ? "static union {"
.SEGMENT TEXT 8203-8216 ? "char nbytes [ NBYTES ] ;"
.SEGMENT TEXT 8217-8229 ? "char nbytes [ NBYTES ] ;"
.SEGMENT TEXT 8265-8273 ? "clock ; short pid ;"
.SEGMENT TEXT 8274-8294 ? "short id ; } stamp ;"
.SEGMENT TEXT 8326-8335 ? "} template ; static"
.SEGMENT TEXT 8336-8362 ? "char quefil [ BUFSIZ ] ;"
.SEGMENT TEXT 8363-8391 ? "char quefil [ BUFSIZ ] ;"
.SEGMENT TEXT 8392-8411 ? "static char wrkfil [ BUFSIZ ] ;"
.SEGMENT TEXT 8430-8451 ? "static FILE *"
.SEGMENT TEXT 8481-8487 ? "fp ; long time"
.SEGMENT TEXT 8505-8522 ? "( ) ; char * cdate"
.SEGMENT TEXT 8523-8535 ? "( ) , * ctime ( ) ;"
.SEGMENT TEXT 8536-8548 ? "( ) , * ctime ( ) ;"
.SEGMENT TEXT 8549-8572 ? "/ * * / int nminit"
.SEGMENT TEXT 8599-8603 ? "( user , clock )"
.SEGMENT TEXT 8604-8609 ? "( user , clock )"
.SEGMENT TEXT 8639-8647 ? "* user ; register"
.SEGMENT TEXT 8648-8657 ? "* user ; register"
.SEGMENT TEXT 8688-8693 ? "quefile ( quefil ,"
.SEGMENT TEXT 8737-8744 ? "unlink ( wrkfil ) ;"
.SEGMENT TEXT 8745-8752 ? "unlink ( wrkfil ) ;"
.SEGMENT TEXT 8822-8835 ? "= NULL ) return"
.SEGMENT TEXT 8849-8861 ? "NOTOK ; ( void )"
.SEGMENT TEXT 8877-8891 ? "chmod ( wrkfil ,"
.SEGMENT TEXT 8902-8911 ? "0600 ) ; fprintf"
.SEGMENT TEXT 9024-9028 ? "nmwadr ( mbox ,"
.SEGMENT TEXT 9045-9064 ? "host ) register"
.SEGMENT TEXT 9065-9079 ? "char * mbox , * host ;"
.SEGMENT TEXT 9094-9116 ? "{ fprintf ( fp ,"
.SEGMENT TEXT 9136-9155 ? "\" / % s % s \\ n \" , host ,"
.SEGMENT TEXT 9225-9240 ? "( ) { putc ( ' \\ n',"
.SEGMENT TEXT 9256-9265 ? "fp ) ; return OK ;"
.SEGMENT TEXT 9275-9300 ? "} int nmwtxt ( buffer ,"
.SEGMENT TEXT 9301-9325 ? "} int nmwtxt ( buffer ,"
.SEGMENT TEXT 9332-9337 ? "cnt ) register"
.SEGMENT TEXT 9373-9382 ? "register int cnt ;"
.SEGMENT TEXT 9383-9392 ? "register int cnt ;"
.SEGMENT TEXT 9393-9418 ? "{ if ( fwrite ( buffer ,"
.SEGMENT TEXT 9452-9458 ? "sizeof * buffer ,"
.SEGMENT TEXT 9520-9537 ? "return OK ; } int"
.SEGMENT TEXT 9565-9573 ? "nmwtend ( ) { ( void )"
.SEGMENT TEXT 9593-9611 ? "fclose ( fp ) ; if"
.SEGMENT TEXT 9612-9618 ? "( link ( wrkfil ,"
.SEGMENT TEXT 9627-9646 ? "| unlink ( wrkfil )"
.SEGMENT TEXT 9647-9665 ? "| unlink ( wrkfil )"
.SEGMENT TEXT 9678-9684 ? "= NOTOK ) return"
.SEGMENT TEXT 9685-9700 ? "NOTOK ; return"
.SEGMENT TEXT 9731-9745 ? "OK ; } / * * /"
.SEGMENT TEXT 9785-9795 ? "( que , lnk ) register"
.SEGMENT TEXT 9796-9804 ? "( que , lnk ) register"
.SEGMENT TEXT 9825-9843 ? "char * que , * lnk ;"
.SEGMENT TEXT 9851-9858 ? "{ register char"
.SEGMENT TEXT 9937-9945 ? "template.stamp.pid"
.SEGMENT TEXT 9946-9954 ? "template.stamp.pid"
.SEGMENT TEXT 9988-10028 ? "= getpid ( ) ; template.stamp.id"
.SEGMENT TEXT 10042-10054 ? "= files + ; if ( files"
.SEGMENT TEXT 10055-10070 ? "> = 256 ) { files"
.SEGMENT TEXT 10071-10086 ? "> = 256 ) { files"
.SEGMENT TEXT 10087-10097 ? "= 0 ; sleep ( 1 ) ;"
.SEGMENT TEXT 10124-10136 ? "} ( void ) time"
.SEGMENT TEXT 10150-10162 ? "( & template.stamp.clock ) ;"
.SEGMENT TEXT 10163-10180 ? "p = buffer ; for"
.SEGMENT TEXT 10211-10222 ? "( q = template.nbytes ;"
.SEGMENT TEXT 10256-10290 ? "q < & template.nbytes [ NBYTES ] ;"
.SEGMENT TEXT 10291-10311 ? "q + ) { * p + = hex [ ( *"
.SEGMENT TEXT 10396-10415 ? "= hex [ ( * q ) & 0 xf ] ;"
.SEGMENT TEXT 10438-10463 ? "} * p = NULL ; ( void )"
.SEGMENT TEXT 10464-10481 ? "\" % s / % s \" , Mailqdir ,"
.SEGMENT TEXT 10518-10535 ? "buffer ) ; ( void )"
.SEGMENT TEXT 10536-10542 ? "sprintf ( lnk ,"
.SEGMENT TEXT 10549-10579 ? "\" % s / % s \" , TMailqdir ,"
.SEGMENT TEXT 10580-10606 ? "\" % s / % s \" , TMailqdir ,"
.SEGMENT TEXT 10616-10624 ? "buffer ) ; } / *"
.SEGMENT TEXT 10625-10641 ? "* / static char"
.SEGMENT TEXT 10665-10673 ? "* cdate ( clock )"
.SEGMENT TEXT 10684-10697 ? "register long"
.SEGMENT TEXT 10698-10711 ? "register long"
.SEGMENT TEXT 10720-10727 ? "* clock ; { char"
.SEGMENT TEXT 10748-10767 ? "* cp ; cp = ctime"
.SEGMENT TEXT 10768-10776 ? "( clock ) ; cp [ 1 ]"
.SEGMENT TEXT 10786-10801 ? "= cp [ 8 ] ; cp [ 2 ]"
.SEGMENT TEXT 10802-10817 ? "= cp [ 8 ] ; cp [ 2 ]"
.SEGMENT TEXT 10818-10829 ? "= cp [ 9 ] ; cp [ 3 ]"
.SEGMENT TEXT 10842-10856 ? "= ' - ' ; cp [ 7 ] ="
.SEGMENT TEXT 10894-10915 ? "' ; cp [ 8 ] = cp [ 22 ] ;"
.SEGMENT TEXT 10916-10932 ? "cp [ 9 ] = cp [ 23 ] ;"
.SEGMENT TEXT 10933-10949 ? "cp [ 9 ] = cp [ 23 ] ;"
.SEGMENT TEXT 10950-10961 ? "cp [ 10 ] = ' @ ' ;"
.SEGMENT TEXT 10962-10973 ? "cp [ 10 ] = ' @ ' ;"
.SEGMENT TEXT 10974-10988 ? "cp [ 19 ] = NULL ;"
.SEGMENT TEXT 10989-11003 ? "cp [ 19 ] = NULL ;"
.SEGMENT TEXT 11012-11019 ? "return cp + 1 ;"
.SEGMENT TEXT 11052-11055 ? "version of fscanf"
.SEGMENT TEXT 11116-11120 ? "comments start"
.SEGMENT TEXT 11121-11124 ? "comments start"
.SEGMENT TEXT 11125-11143 ? "with a hash ( # )"
.SEGMENT TEXT 11144-11160 ? "with a hash ( # )"
.SEGMENT TEXT 11161-11166 ? "and run to the"
.SEGMENT TEXT 11167-11172 ? "and run to the"
.SEGMENT TEXT 11173-11188 ? "end of the line"
.SEGMENT TEXT 11205-11212 ? "Restrictions :"
.SEGMENT TEXT 11260-11262 ? "once. Therefore"
.SEGMENT TEXT 11288-11308 ? "f 1scanf ( fp , \" % d"
.SEGMENT TEXT 11325-11339 ? "% d \" , & a , & b ) ;"
.SEGMENT TEXT 11340-11360 ? "will fail if there"
.SEGMENT TEXT 11389-11396 ? "is a comment between"
.SEGMENT TEXT 11428-11429 ? "The preferred"
.SEGMENT TEXT 11430-11431 ? "The preferred"
.SEGMENT TEXT 11468-11472 ? "read one at a"
.SEGMENT TEXT 11473-11479 ? "read one at a"
.SEGMENT TEXT 11480-11502 ? "time : f 1scanf ( fp ,"
.SEGMENT TEXT 11527-11549 ? "\" , & a ) ; f 1scanf ( fp ,"
.SEGMENT TEXT 11573-11592 ? "\" % d \" , & b ) ; Also ,"
.SEGMENT TEXT 11593-11612 ? "\" % d \" , & b ) ; Also ,"
.SEGMENT TEXT 11613-11626 ? "strings with \" % s \""
.SEGMENT TEXT 11627-11640 ? "strings with \" % s \""
.SEGMENT TEXT 11641-11658 ? "format , you must"
.SEGMENT TEXT 11659-11676 ? "format , you must"
.SEGMENT TEXT 11721-11727 ? "your string with"
.SEGMENT TEXT 11728-11734 ? "your string with"
.SEGMENT TEXT 11747-11759 ? "a space , tab ,"
.SEGMENT TEXT 11760-11766 ? "or newline. * /"
.SEGMENT TEXT 11774-11794 ? "/ * Usage example :"
.SEGMENT TEXT 11795-11812 ? "/ * Usage example :"
.SEGMENT TEXT 11813-11828 ? "* # include < stdio.h >"
.SEGMENT TEXT 11829-11844 ? "* # include < stdio.h >"
.SEGMENT TEXT 11930-11943 ? "char * argv ) {"
.SEGMENT TEXT 11944-11953 ? "if ( argc ) if ( argv )"
.SEGMENT TEXT 11964-11980 ? "; int krud ; char"
.SEGMENT TEXT 11998-12008 ? "str [ 100 ] ; int"
.SEGMENT TEXT 12089-12106 ? "\" % 99 s \" , str ) ;"
.SEGMENT TEXT 12114-12121 ? "if ( krud < 0 )"
